#
# Autogenerated by Thrift Compiler (0.13.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class MusicGender(object):
    Pop = 1
    Rock = 2
    Bachata = 3
    Balada = 4
    Blues = 5
    Clasica = 6
    Corrido = 7
    Country = 8
    Cumbia = 9
    Electronica = 10
    Flamenco = 11
    Reggaeton = 12
    Punk = 13
    Funk = 14
    Metal = 15
    HipHop = 16
    Indie = 17
    Jazz = 18
    Merengue = 19
    Salsa = 20
    Reggae = 21
    RocknRoll = 22
    Ska = 23
    Trap = 24
    Son = 25
    Vals = 26
    Ranchero = 27
    BosaNova = 28
    Bolero = 29
    Disco = 30

    _VALUES_TO_NAMES = {
        1: "Pop",
        2: "Rock",
        3: "Bachata",
        4: "Balada",
        5: "Blues",
        6: "Clasica",
        7: "Corrido",
        8: "Country",
        9: "Cumbia",
        10: "Electronica",
        11: "Flamenco",
        12: "Reggaeton",
        13: "Punk",
        14: "Funk",
        15: "Metal",
        16: "HipHop",
        17: "Indie",
        18: "Jazz",
        19: "Merengue",
        20: "Salsa",
        21: "Reggae",
        22: "RocknRoll",
        23: "Ska",
        24: "Trap",
        25: "Son",
        26: "Vals",
        27: "Ranchero",
        28: "BosaNova",
        29: "Bolero",
        30: "Disco",
    }

    _NAMES_TO_VALUES = {
        "Pop": 1,
        "Rock": 2,
        "Bachata": 3,
        "Balada": 4,
        "Blues": 5,
        "Clasica": 6,
        "Corrido": 7,
        "Country": 8,
        "Cumbia": 9,
        "Electronica": 10,
        "Flamenco": 11,
        "Reggaeton": 12,
        "Punk": 13,
        "Funk": 14,
        "Metal": 15,
        "HipHop": 16,
        "Indie": 17,
        "Jazz": 18,
        "Merengue": 19,
        "Salsa": 20,
        "Reggae": 21,
        "RocknRoll": 22,
        "Ska": 23,
        "Trap": 24,
        "Son": 25,
        "Vals": 26,
        "Ranchero": 27,
        "BosaNova": 28,
        "Bolero": 29,
        "Disco": 30,
    }


class SErrorType(object):
    UNKNOWN = 1
    PERMISSION_DENIED = 2
    INTERNAL_ERROR = 3
    AUTHENTICATION_FAILURE = 4
    INVALID_AUTHORIZATION = 5
    AUTORIZATHION_EXPIRED = 6
    UNKNOWN_GATEWAY_ID = 7
    UNSUPPORTED_OPERATION = 8

    _VALUES_TO_NAMES = {
        1: "UNKNOWN",
        2: "PERMISSION_DENIED",
        3: "INTERNAL_ERROR",
        4: "AUTHENTICATION_FAILURE",
        5: "INVALID_AUTHORIZATION",
        6: "AUTORIZATHION_EXPIRED",
        7: "UNKNOWN_GATEWAY_ID",
        8: "UNSUPPORTED_OPERATION",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 1,
        "PERMISSION_DENIED": 2,
        "INTERNAL_ERROR": 3,
        "AUTHENTICATION_FAILURE": 4,
        "INVALID_AUTHORIZATION": 5,
        "AUTORIZATHION_EXPIRED": 6,
        "UNKNOWN_GATEWAY_ID": 7,
        "UNSUPPORTED_OPERATION": 8,
    }


class Consumer(object):
    """
    This file describes the definitions of the model which encapsulates
    the information that needs to be passed to the API methods in order to
    manage Consumer and Content Creator users and Content.


    Attributes:
     - idConsumer
     - givenName
     - lastName
     - email
     - password
     - imageStoragePath

    """


    def __init__(self, idConsumer=None, givenName=None, lastName=None, email=None, password=None, imageStoragePath=None,):
        self.idConsumer = idConsumer
        self.givenName = givenName
        self.lastName = lastName
        self.email = email
        self.password = password
        self.imageStoragePath = imageStoragePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idConsumer = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.givenName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.lastName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.imageStoragePath = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Consumer')
        if self.idConsumer is not None:
            oprot.writeFieldBegin('idConsumer', TType.I16, 1)
            oprot.writeI16(self.idConsumer)
            oprot.writeFieldEnd()
        if self.givenName is not None:
            oprot.writeFieldBegin('givenName', TType.STRING, 2)
            oprot.writeString(self.givenName.encode('utf-8') if sys.version_info[0] == 2 else self.givenName)
            oprot.writeFieldEnd()
        if self.lastName is not None:
            oprot.writeFieldBegin('lastName', TType.STRING, 3)
            oprot.writeString(self.lastName.encode('utf-8') if sys.version_info[0] == 2 else self.lastName)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 4)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 5)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.imageStoragePath is not None:
            oprot.writeFieldBegin('imageStoragePath', TType.STRING, 6)
            oprot.writeString(self.imageStoragePath.encode('utf-8') if sys.version_info[0] == 2 else self.imageStoragePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idConsumer is None:
            raise TProtocolException(message='Required field idConsumer is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ContentCreator(object):
    """
    Attributes:
     - idContentCreator
     - givenName
     - lastName
     - email
     - password
     - stageName
     - description
     - imageStoragePath

    """


    def __init__(self, idContentCreator=None, givenName=None, lastName=None, email=None, password=None, stageName=None, description=None, imageStoragePath=None,):
        self.idContentCreator = idContentCreator
        self.givenName = givenName
        self.lastName = lastName
        self.email = email
        self.password = password
        self.stageName = stageName
        self.description = description
        self.imageStoragePath = imageStoragePath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idContentCreator = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.givenName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.lastName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.email = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.password = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.stageName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRING:
                    self.imageStoragePath = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ContentCreator')
        if self.idContentCreator is not None:
            oprot.writeFieldBegin('idContentCreator', TType.I16, 1)
            oprot.writeI16(self.idContentCreator)
            oprot.writeFieldEnd()
        if self.givenName is not None:
            oprot.writeFieldBegin('givenName', TType.STRING, 2)
            oprot.writeString(self.givenName.encode('utf-8') if sys.version_info[0] == 2 else self.givenName)
            oprot.writeFieldEnd()
        if self.lastName is not None:
            oprot.writeFieldBegin('lastName', TType.STRING, 3)
            oprot.writeString(self.lastName.encode('utf-8') if sys.version_info[0] == 2 else self.lastName)
            oprot.writeFieldEnd()
        if self.email is not None:
            oprot.writeFieldBegin('email', TType.STRING, 4)
            oprot.writeString(self.email.encode('utf-8') if sys.version_info[0] == 2 else self.email)
            oprot.writeFieldEnd()
        if self.password is not None:
            oprot.writeFieldBegin('password', TType.STRING, 5)
            oprot.writeString(self.password.encode('utf-8') if sys.version_info[0] == 2 else self.password)
            oprot.writeFieldEnd()
        if self.stageName is not None:
            oprot.writeFieldBegin('stageName', TType.STRING, 6)
            oprot.writeString(self.stageName.encode('utf-8') if sys.version_info[0] == 2 else self.stageName)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 7)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.imageStoragePath is not None:
            oprot.writeFieldBegin('imageStoragePath', TType.STRING, 8)
            oprot.writeString(self.imageStoragePath.encode('utf-8') if sys.version_info[0] == 2 else self.imageStoragePath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idContentCreator is None:
            raise TProtocolException(message='Required field idContentCreator is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class ExceptionUser(TException):
    """
    Attributes:
     - message
     - error_code

    """


    def __init__(self, message=None, error_code=None,):
        self.message = message
        self.error_code = error_code

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.error_code = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ExceptionUser')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.error_code is not None:
            oprot.writeFieldBegin('error_code', TType.I16, 2)
            oprot.writeI16(self.error_code)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Track(object):
    """
    Attributes:
     - idTrack
     - trackNumber
     - duartionSeconds
     - storagePath
     - title
     - gender

    """


    def __init__(self, idTrack=None, trackNumber=None, duartionSeconds=None, storagePath=None, title=None, gender=None,):
        self.idTrack = idTrack
        self.trackNumber = trackNumber
        self.duartionSeconds = duartionSeconds
        self.storagePath = storagePath
        self.title = title
        self.gender = gender

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idTrack = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.trackNumber = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.duartionSeconds = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.storagePath = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.gender = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Track')
        if self.idTrack is not None:
            oprot.writeFieldBegin('idTrack', TType.I16, 1)
            oprot.writeI16(self.idTrack)
            oprot.writeFieldEnd()
        if self.trackNumber is not None:
            oprot.writeFieldBegin('trackNumber', TType.I16, 2)
            oprot.writeI16(self.trackNumber)
            oprot.writeFieldEnd()
        if self.duartionSeconds is not None:
            oprot.writeFieldBegin('duartionSeconds', TType.DOUBLE, 3)
            oprot.writeDouble(self.duartionSeconds)
            oprot.writeFieldEnd()
        if self.storagePath is not None:
            oprot.writeFieldBegin('storagePath', TType.STRING, 4)
            oprot.writeString(self.storagePath.encode('utf-8') if sys.version_info[0] == 2 else self.storagePath)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 5)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.gender is not None:
            oprot.writeFieldBegin('gender', TType.I32, 6)
            oprot.writeI32(self.gender)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idTrack is None:
            raise TProtocolException(message='Required field idTrack is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Date(object):
    """
    Attributes:
     - day
     - month
     - year

    """


    def __init__(self, day=None, month=None, year=None,):
        self.day = day
        self.month = month
        self.year = year

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.day = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.month = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.year = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Date')
        if self.day is not None:
            oprot.writeFieldBegin('day', TType.I16, 1)
            oprot.writeI16(self.day)
            oprot.writeFieldEnd()
        if self.month is not None:
            oprot.writeFieldBegin('month', TType.I16, 2)
            oprot.writeI16(self.month)
            oprot.writeFieldEnd()
        if self.year is not None:
            oprot.writeFieldBegin('year', TType.I16, 3)
            oprot.writeI16(self.year)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Album(object):
    """
    Attributes:
     - idAlbum
     - title
     - coverPath
     - releaseDate
     - gender
     - isSingle

    """


    def __init__(self, idAlbum=None, title=None, coverPath=None, releaseDate=None, gender=None, isSingle=None,):
        self.idAlbum = idAlbum
        self.title = title
        self.coverPath = coverPath
        self.releaseDate = releaseDate
        self.gender = gender
        self.isSingle = isSingle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idAlbum = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.title = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.coverPath = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.releaseDate = Date()
                    self.releaseDate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.gender = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isSingle = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Album')
        if self.idAlbum is not None:
            oprot.writeFieldBegin('idAlbum', TType.I16, 1)
            oprot.writeI16(self.idAlbum)
            oprot.writeFieldEnd()
        if self.title is not None:
            oprot.writeFieldBegin('title', TType.STRING, 2)
            oprot.writeString(self.title.encode('utf-8') if sys.version_info[0] == 2 else self.title)
            oprot.writeFieldEnd()
        if self.coverPath is not None:
            oprot.writeFieldBegin('coverPath', TType.STRING, 3)
            oprot.writeString(self.coverPath.encode('utf-8') if sys.version_info[0] == 2 else self.coverPath)
            oprot.writeFieldEnd()
        if self.releaseDate is not None:
            oprot.writeFieldBegin('releaseDate', TType.STRUCT, 4)
            self.releaseDate.write(oprot)
            oprot.writeFieldEnd()
        if self.gender is not None:
            oprot.writeFieldBegin('gender', TType.I32, 5)
            oprot.writeI32(self.gender)
            oprot.writeFieldEnd()
        if self.isSingle is not None:
            oprot.writeFieldBegin('isSingle', TType.BOOL, 6)
            oprot.writeBool(self.isSingle)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idAlbum is None:
            raise TProtocolException(message='Required field idAlbum is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Playlist(object):
    """
    Attributes:
     - idPlaylist
     - name
     - description
     - creationDate
     - Tracks
     - coverPath

    """


    def __init__(self, idPlaylist=None, name=None, description=None, creationDate=None, Tracks=[
    ], coverPath=None,):
        self.idPlaylist = idPlaylist
        self.name = name
        self.description = description
        self.creationDate = creationDate
        if Tracks is self.thrift_spec[5][4]:
            Tracks = [
            ]
        self.Tracks = Tracks
        self.coverPath = coverPath

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idPlaylist = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.description = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.creationDate = Date()
                    self.creationDate.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.Tracks = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = Track()
                        _elem5.read(iprot)
                        self.Tracks.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.coverPath = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Playlist')
        if self.idPlaylist is not None:
            oprot.writeFieldBegin('idPlaylist', TType.I16, 1)
            oprot.writeI16(self.idPlaylist)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.description is not None:
            oprot.writeFieldBegin('description', TType.STRING, 3)
            oprot.writeString(self.description.encode('utf-8') if sys.version_info[0] == 2 else self.description)
            oprot.writeFieldEnd()
        if self.creationDate is not None:
            oprot.writeFieldBegin('creationDate', TType.STRUCT, 4)
            self.creationDate.write(oprot)
            oprot.writeFieldEnd()
        if self.Tracks is not None:
            oprot.writeFieldBegin('Tracks', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.Tracks))
            for iter6 in self.Tracks:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.coverPath is not None:
            oprot.writeFieldBegin('coverPath', TType.STRING, 6)
            oprot.writeString(self.coverPath.encode('utf-8') if sys.version_info[0] == 2 else self.coverPath)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idPlaylist is None:
            raise TProtocolException(message='Required field idPlaylist is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class PlayQueue(object):
    """
    Attributes:
     - idPlayQueu
     - Tracks

    """


    def __init__(self, idPlayQueu=None, Tracks=[
    ],):
        self.idPlayQueu = idPlayQueu
        if Tracks is self.thrift_spec[2][4]:
            Tracks = [
            ]
        self.Tracks = Tracks

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idPlayQueu = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.Tracks = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = Track()
                        _elem12.read(iprot)
                        self.Tracks.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('PlayQueue')
        if self.idPlayQueu is not None:
            oprot.writeFieldBegin('idPlayQueu', TType.I16, 1)
            oprot.writeI16(self.idPlayQueu)
            oprot.writeFieldEnd()
        if self.Tracks is not None:
            oprot.writeFieldBegin('Tracks', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.Tracks))
            for iter13 in self.Tracks:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idPlayQueu is None:
            raise TProtocolException(message='Required field idPlayQueu is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class Library(object):
    """
    Attributes:
     - idLibrary
     - Tracks
     - Albums
     - Playlists
     - ContentCreators

    """


    def __init__(self, idLibrary=None, Tracks=[
    ], Albums=[
    ], Playlists=[
    ], ContentCreators=[
    ],):
        self.idLibrary = idLibrary
        if Tracks is self.thrift_spec[2][4]:
            Tracks = [
            ]
        self.Tracks = Tracks
        if Albums is self.thrift_spec[3][4]:
            Albums = [
            ]
        self.Albums = Albums
        if Playlists is self.thrift_spec[4][4]:
            Playlists = [
            ]
        self.Playlists = Playlists
        if ContentCreators is self.thrift_spec[5][4]:
            ContentCreators = [
            ]
        self.ContentCreators = ContentCreators

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.idLibrary = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.Tracks = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = Track()
                        _elem19.read(iprot)
                        self.Tracks.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.Albums = []
                    (_etype23, _size20) = iprot.readListBegin()
                    for _i24 in range(_size20):
                        _elem25 = Album()
                        _elem25.read(iprot)
                        self.Albums.append(_elem25)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.Playlists = []
                    (_etype29, _size26) = iprot.readListBegin()
                    for _i30 in range(_size26):
                        _elem31 = Playlist()
                        _elem31.read(iprot)
                        self.Playlists.append(_elem31)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.ContentCreators = []
                    (_etype35, _size32) = iprot.readListBegin()
                    for _i36 in range(_size32):
                        _elem37 = ContentCreator()
                        _elem37.read(iprot)
                        self.ContentCreators.append(_elem37)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Library')
        if self.idLibrary is not None:
            oprot.writeFieldBegin('idLibrary', TType.I16, 1)
            oprot.writeI16(self.idLibrary)
            oprot.writeFieldEnd()
        if self.Tracks is not None:
            oprot.writeFieldBegin('Tracks', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.Tracks))
            for iter38 in self.Tracks:
                iter38.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Albums is not None:
            oprot.writeFieldBegin('Albums', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.Albums))
            for iter39 in self.Albums:
                iter39.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Playlists is not None:
            oprot.writeFieldBegin('Playlists', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.Playlists))
            for iter40 in self.Playlists:
                iter40.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ContentCreators is not None:
            oprot.writeFieldBegin('ContentCreators', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.ContentCreators))
            for iter41 in self.ContentCreators:
                iter41.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.idLibrary is None:
            raise TProtocolException(message='Required field idLibrary is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class RelatedResult(object):
    """
    Attributes:
     - Tracks
     - Albums
     - Playlists
     - ContentCreators

    """


    def __init__(self, Tracks=[
    ], Albums=[
    ], Playlists=[
    ], ContentCreators=[
    ],):
        if Tracks is self.thrift_spec[1][4]:
            Tracks = [
            ]
        self.Tracks = Tracks
        if Albums is self.thrift_spec[2][4]:
            Albums = [
            ]
        self.Albums = Albums
        if Playlists is self.thrift_spec[3][4]:
            Playlists = [
            ]
        self.Playlists = Playlists
        if ContentCreators is self.thrift_spec[4][4]:
            ContentCreators = [
            ]
        self.ContentCreators = ContentCreators

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.Tracks = []
                    (_etype45, _size42) = iprot.readListBegin()
                    for _i46 in range(_size42):
                        _elem47 = Track()
                        _elem47.read(iprot)
                        self.Tracks.append(_elem47)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.Albums = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = Album()
                        _elem53.read(iprot)
                        self.Albums.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.Playlists = []
                    (_etype57, _size54) = iprot.readListBegin()
                    for _i58 in range(_size54):
                        _elem59 = Playlist()
                        _elem59.read(iprot)
                        self.Playlists.append(_elem59)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.ContentCreators = []
                    (_etype63, _size60) = iprot.readListBegin()
                    for _i64 in range(_size60):
                        _elem65 = ContentCreator()
                        _elem65.read(iprot)
                        self.ContentCreators.append(_elem65)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('RelatedResult')
        if self.Tracks is not None:
            oprot.writeFieldBegin('Tracks', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.Tracks))
            for iter66 in self.Tracks:
                iter66.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Albums is not None:
            oprot.writeFieldBegin('Albums', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.Albums))
            for iter67 in self.Albums:
                iter67.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.Playlists is not None:
            oprot.writeFieldBegin('Playlists', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.Playlists))
            for iter68 in self.Playlists:
                iter68.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ContentCreators is not None:
            oprot.writeFieldBegin('ContentCreators', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.ContentCreators))
            for iter69 in self.ContentCreators:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SErrorUserException(TException):
    """
    This is exception is thrown by SError procedures when
    a call fails as a result of a problem that a caller may be able to resolve.

    error_code: The numeric code indicating the type of error that occurred.
    Must be one of the values of SErrorType

    message: This may contain additional information about the error.

    Attributes:
     - error_code
     - message

    """


    def __init__(self, error_code=None, message=None,):
        self.error_code = error_code
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.error_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SErrorUserException')
        if self.error_code is not None:
            oprot.writeFieldBegin('error_code', TType.I32, 1)
            oprot.writeI32(self.error_code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.error_code is None:
            raise TProtocolException(message='Required field error_code is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SErrorSystemException(TException):
    """
    This exception is thrown by SError procedures when a call fails as a result of
    a problem in the service that could not be changed through caller action.

    error_code: The numeric code indicating the type of error that occurred.
    Must be one of the values of SErrorType

    message: This may contain additional information about the error.

    rateLimitDuration: Indicates the minimum number of seconds that an application
    should expect subsequent API calls for this user to fail.

    Attributes:
     - error_code
     - message
     - rateLimitDuration

    """


    def __init__(self, error_code=None, message=None, rateLimitDuration=None,):
        self.error_code = error_code
        self.message = message
        self.rateLimitDuration = rateLimitDuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.error_code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.rateLimitDuration = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SErrorSystemException')
        if self.error_code is not None:
            oprot.writeFieldBegin('error_code', TType.I32, 1)
            oprot.writeI32(self.error_code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.rateLimitDuration is not None:
            oprot.writeFieldBegin('rateLimitDuration', TType.I32, 3)
            oprot.writeI32(self.rateLimitDuration)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.error_code is None:
            raise TProtocolException(message='Required field error_code is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SErrorNotFoundException(TException):
    """
    This exception is thrown by SError procedures when a caller asks to perform an operation on
    an object that does not exist.

    identifier: A description of the object that was not found on the serve.

    key: The value passed from the client in the identifier, which was not found.

    Attributes:
     - identifier
     - key

    """


    def __init__(self, identifier=None, key=None,):
        self.identifier = identifier
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.identifier = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SErrorNotFoundException')
        if self.identifier is not None:
            oprot.writeFieldBegin('identifier', TType.STRING, 1)
            oprot.writeString(self.identifier.encode('utf-8') if sys.version_info[0] == 2 else self.identifier)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 2)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.identifier is None:
            raise TProtocolException(message='Required field identifier is unset!')
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class SErrorInvalidRequestException(TException):
    """
    This exception is thrown for invalid requests that occur
    from any reasons like required input parameters are missing,
    or a parameter is malformed.

    message: ontains the associated error message.

    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SErrorInvalidRequestException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Consumer)
Consumer.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idConsumer', None, None, ),  # 1
    (2, TType.STRING, 'givenName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'lastName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'email', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'password', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'imageStoragePath', 'UTF8', None, ),  # 6
)
all_structs.append(ContentCreator)
ContentCreator.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idContentCreator', None, None, ),  # 1
    (2, TType.STRING, 'givenName', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'lastName', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'email', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'password', 'UTF8', None, ),  # 5
    (6, TType.STRING, 'stageName', 'UTF8', None, ),  # 6
    (7, TType.STRING, 'description', 'UTF8', None, ),  # 7
    (8, TType.STRING, 'imageStoragePath', 'UTF8', None, ),  # 8
)
all_structs.append(ExceptionUser)
ExceptionUser.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I16, 'error_code', None, None, ),  # 2
)
all_structs.append(Track)
Track.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idTrack', None, None, ),  # 1
    (2, TType.I16, 'trackNumber', None, None, ),  # 2
    (3, TType.DOUBLE, 'duartionSeconds', None, None, ),  # 3
    (4, TType.STRING, 'storagePath', 'UTF8', None, ),  # 4
    (5, TType.STRING, 'title', 'UTF8', None, ),  # 5
    (6, TType.I32, 'gender', None, None, ),  # 6
)
all_structs.append(Date)
Date.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'day', None, None, ),  # 1
    (2, TType.I16, 'month', None, None, ),  # 2
    (3, TType.I16, 'year', None, None, ),  # 3
)
all_structs.append(Album)
Album.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idAlbum', None, None, ),  # 1
    (2, TType.STRING, 'title', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'coverPath', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'releaseDate', [Date, None], None, ),  # 4
    (5, TType.I32, 'gender', None, None, ),  # 5
    (6, TType.BOOL, 'isSingle', None, None, ),  # 6
)
all_structs.append(Playlist)
Playlist.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idPlaylist', None, None, ),  # 1
    (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'description', 'UTF8', None, ),  # 3
    (4, TType.STRUCT, 'creationDate', [Date, None], None, ),  # 4
    (5, TType.LIST, 'Tracks', (TType.STRUCT, [Track, None], False), [
    ], ),  # 5
    (6, TType.STRING, 'coverPath', 'UTF8', None, ),  # 6
)
all_structs.append(PlayQueue)
PlayQueue.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idPlayQueu', None, None, ),  # 1
    (2, TType.LIST, 'Tracks', (TType.STRUCT, [Track, None], False), [
    ], ),  # 2
)
all_structs.append(Library)
Library.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'idLibrary', None, None, ),  # 1
    (2, TType.LIST, 'Tracks', (TType.STRUCT, [Track, None], False), [
    ], ),  # 2
    (3, TType.LIST, 'Albums', (TType.STRUCT, [Album, None], False), [
    ], ),  # 3
    (4, TType.LIST, 'Playlists', (TType.STRUCT, [Playlist, None], False), [
    ], ),  # 4
    (5, TType.LIST, 'ContentCreators', (TType.STRUCT, [ContentCreator, None], False), [
    ], ),  # 5
)
all_structs.append(RelatedResult)
RelatedResult.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'Tracks', (TType.STRUCT, [Track, None], False), [
    ], ),  # 1
    (2, TType.LIST, 'Albums', (TType.STRUCT, [Album, None], False), [
    ], ),  # 2
    (3, TType.LIST, 'Playlists', (TType.STRUCT, [Playlist, None], False), [
    ], ),  # 3
    (4, TType.LIST, 'ContentCreators', (TType.STRUCT, [ContentCreator, None], False), [
    ], ),  # 4
)
all_structs.append(SErrorUserException)
SErrorUserException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'error_code', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(SErrorSystemException)
SErrorSystemException.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'error_code', None, None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
    (3, TType.I32, 'rateLimitDuration', None, None, ),  # 3
)
all_structs.append(SErrorNotFoundException)
SErrorNotFoundException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'identifier', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'key', 'UTF8', None, ),  # 2
)
all_structs.append(SErrorInvalidRequestException)
SErrorInvalidRequestException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
